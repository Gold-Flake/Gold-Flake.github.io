<!DOCTYPE html>
<html>
	<head>
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<style>
			canvas {
				border: 1px solid #d3d3d3;
				background-color: #f1f1f1;
			}

            #main {
                text-align: center;
            }
		</style>
	</head>
    <body onload="startGame()">
        <div id="main">
        <p1 id="score"> </p1>
        
		<script>
            var snakeHead;
            const boxSize = 30;
            const canvasWidth = 36*boxSize;
            const canvasHeight = 21*boxSize;
            var div = document.getElementById("main");
            var score = document.getElementById("score");
            var moveSpeed = boxSize;
            var lockMovement = true;
            var queuedKey = null;
            var originalClasses = [101,114,160,161,214,215,216,220,300,303,306,307,310,311,312,316,320,327,334,337,351,352,354,371,373,376,380,385,416,506,512,526,527,532,540,541,544,545,548,550,555,564,566,600,645];
            var remainingClasses = [...originalClasses];
            var edibleClass = null;

			function startGame() {
				snakeHead = new component(boxSize, boxSize, "red", canvasWidth/2, canvasHeight/2 - boxSize/2, "");
                myGameArea.start();
                moveUp();
                spawnClass();
            }
            
			var myGameArea = {  
				canvas: document.createElement("canvas"),
				start: function () {
					this.canvas.width = canvasWidth;
					this.canvas.height = canvasHeight;
					this.context = this.canvas.getContext("2d");
					div.prepend(this.canvas);
					this.interval = setInterval(updateGameArea, 500);
				},
				clear: function () {
					this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
                },
            };
            
			function component(width, height, color, x, y, label) {
				this.width = width;
				this.height = height;
				this.speedX = 0;
				this.speedY = 0;
				this.x = x;
                this.y = y;
                this.oldX = x;
                this.oldY = y;
                this.nextComponent = null;

				this.update = function () {
					ctx = myGameArea.context;
                    ctx.fillStyle = color;
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                    ctx.font = "15px Arial";
                    ctx.fillStyle = 'black';
                    ctx.fillText(label, this.x, this.y+20);
				};
				this.newPos = function () {
                    this.oldX = this.x;
                    this.oldY = this.y;
					this.x += this.speedX;
                    this.y += this.speedY;
                };
                this.resetPos = function () {
                    this.x = x;
                    this.y = y;
                    this.oldX = x;
                    this.oldY = y;
                    this.speedX = 0;
                    this.speedY = 0;
                };
                this.passLocation = function () {
                    if(this.nextComponent != null) {
                        this.nextComponent.oldX = this.nextComponent.x;
                        this.nextComponent.oldY = this.nextComponent.y;
                        this.nextComponent.x = this.oldX;
                        this.nextComponent.y = this.oldY;
                        this.nextComponent.update();
                        
                        this.nextComponent.passLocation();
                    }
                };
            }
            
			function updateGameArea() {
				myGameArea.clear();
				snakeHead.newPos();
                snakeHead.update();
                edibleClass.update();
                snakeHead.passLocation();
                if(edibleClass != null && snakeHead.x == edibleClass.x && snakeHead.y == edibleClass.y) {
                    eatClass();
                }

                score.innerHTML = "Remaining Classes: <b>" + remainingClasses.length + "</b"; 
                
                if(outOfBounds() || isTouchingBody()) {
                    loseGame();
                }
                else {
                    lockMovement = false;
                    checkQueue(); 
                }
            }

            function outOfBounds() {
                if (snakeHead.x - 1 + boxSize >= myGameArea.canvas.width ||
                    snakeHead.x + 1 <= 0 ||
                    snakeHead.y - 1 + boxSize >= myGameArea.canvas.height ||
                    snakeHead.y + 1 <= 0)
                        return true;
                return false;
            }

            function isTouchingBody() {
                if(snakeHead.nextComponent != null) {
                    var node = snakeHead.nextComponent;
                    while(node.nextComponent != null) {
                        console.log(node.x + " == " + snakeHead.x + " && " + node.y + " == " + snakeHead.y + " --> " + node.x == snakeHead.x && node.y == snakeHead.y);
                        if(node.oldX == snakeHead.x && node.oldY == snakeHead.y) {
                            return true;
                        }
                        else {
                            node = node.nextComponent;
                        }
                    }

                    return false;
                }
            }

            function loseGame() {
                alert("You lost! :(");
                
                resetGame();
            }

            function winGame() {
                alert("You won! :)");

                resetGame();
            }

            function resetGame() {
                snakeHead.resetPos();
                moveUp();
                queuedKey == null;
                snakeHead.nextComponent = null; //destroys body. This might cause memory problems... but it's probably fine
                remainingClasses = [...originalClasses];
                spawnClass();
            }

            function isSafeSpawn(x, y) {
                var node = snakeHead;
                while(node.nextComponent != null) {
                    if(node.x == x && node.y == y) {
                        return false;
                    }

                    node = node.nextComponent;
                }

                return true;
            }

            function spawnClass() {
                do {
                    var randX = Math.floor(Math.random() * 36) * 30;
                    var randY = Math.floor(Math.random() * 21) * 30;
                } while(!isSafeSpawn(randX, randY));
                var randClassIndex = Math.floor(Math.random() * remainingClasses.length) - 1;
                var label = remainingClasses.splice(randClassIndex, 1)[0];

                edibleClass = new component(boxSize, boxSize, 'orange', randX, randY, label);     
            }

            function eatClass() {
                if(remainingClasses.length == 0) {
                    winGame();
                }
                else {
                    var tail = snakeHead;
                    while(tail.nextComponent != null) {
                        tail = tail.nextComponent;
                    }
                    tail.nextComponent = new component(boxSize, boxSize, 'green', tail.x, tail.y, "");
                    tail.passLocation(); //yeahhh... really not sure about this one LOL  
                    spawnClass();
                }

            }
            
			function moveUp() {
                if(snakeHead.speedY != moveSpeed) {
                    snakeHead.speedY = -moveSpeed;
                    snakeHead.speedX = 0;
                    lockMovement = true; 
                }
			}
			function moveDown() {
                if(snakeHead.speedY != -moveSpeed) {
                    snakeHead.speedY = moveSpeed;
                    snakeHead.speedX = 0;
                    lockMovement = true; 
                }
			}
			function moveLeft() {
                if(snakeHead.speedX != moveSpeed) {
                    snakeHead.speedX = -moveSpeed;
                    snakeHead.speedY = 0;
                    lockMovement = true; 
                }
			}
			function moveRight() {
                if(snakeHead.speedX != -moveSpeed) {
                    snakeHead.speedX = moveSpeed;
                    snakeHead.speedY = 0;
                    lockMovement = true; 
                }
            }

            document.onkeydown = checkKey;
            function checkKey(e) {
                if(e == null)  
                    e = window.KeyboardEvent;

                if(lockMovement == false) { //don't accept any more movement keys if there was already one input this frame. Prevents on-the-spot turns!
                    if(e.keyCode === 38) { //UP
                        moveUp();
                    }
                    else if(e.keyCode === 40) { //DOWN
                        moveDown();
                    }
                    else if(e.keyCode === 37) { //LEFT
                        moveLeft();
                    }
                    else if(e.keyCode === 39) { //RIGHT
                        moveRight();
                    }
                }

                else {
                    if(queuedKey == null) //can only queue one key at a time, makes it less confusing
                        queuedKey = e; //if there is a key pressed before the lock is released, queue it
                }
            }

            function checkQueue() { //runs the qeued key, if there is one. Makes U-turns easier!
                if (queuedKey != null) {
                    checkKey(queuedKey);
                    queuedKey = null;
                }
            }
            
        </script>
        </div>
	</body>
</html>
